# Memory System Specification

## Purpose

管理创作项目中的角色记忆、世界观设定和情节事件的存储与检索，持续学习用户写作偏好，确保 AI 续写时能获得相关且适量的上下文信息。采用三层记忆架构（工作记忆 / 情景记忆 / 语义记忆），模仿人类认知科学中的多存储模型。

### Scope

| Layer    | Path                                 |
| -------- | ------------------------------------ |
| Backend  | `main/src/services/memory/`          |
| IPC      | `main/src/ipc/memory.ts`             |
| Frontend | `renderer/src/features/memory/`      |
| Store    | `renderer/src/stores/memoryStore.ts` |

## Requirements

### Requirement: 三层记忆架构

系统**必须**实现三层记忆架构，每层有独立的存储机制、生命周期和用途：

```
┌─────────────────────────────────────────────┐
│              Memory System                   │
│                                              │
│  ┌──────────┐  蒸馏   ┌──────────────────┐  │
│  │ Semantic  │ ◄───── │    Episodic      │  │
│  │ Memory    │        │    Memory         │  │
│  └──────────┘        └──────────────────┘  │
│       ▲                      ▲              │
│       │ 查询                  │ 归档         │
│       │                      │              │
│  ┌──────────────────────────────────────┐   │
│  │         Working Memory               │   │
│  └──────────────────────────────────────┘   │
└─────────────────────────────────────────────┘
```

**Layer 1：工作记忆（Working Memory）**

- 当前编辑会话的实时上下文缓冲区，**不持久化**到磁盘
- 存储内容：当前编辑焦点、会话意图栈、撤销/重做缓冲、临时偏好信号、AI 交互上下文
- 存储方式：纯内存（Zustand store），不写入 SQLite
- 容量限制：上限 8K tokens，采用**滑动窗口 + 重要性加权**策略裁剪
- 每条记忆项有 `importance` 分数，由语义相关度、时间衰减、用户交互次数决定
- 会话结束时清除或压缩归档到情景记忆
- 直接喂入 Context Engine 的 **Immediate 层**

**Layer 2：情景记忆（Episodic Memory）**

- 具体的、可回溯的交互事件记录，是语义记忆蒸馏的原材料
- 持久化到 SQLite，每个 Episode 一行
- 索引维度：时间索引（timestamp）、项目索引（projectId）、场景类型索引（sceneType）、语义索引（embedding 向量）
- 召回方式：场景类型 + 语义相似度混合召回

**Layer 3：语义记忆（Semantic Memory）**

- 从情景记忆中自动蒸馏出的抽象规律和偏好模型
- 以自然语言规则形式存储，可直接注入 Context Engine 的 **Settings 层**
- 每条规则有 `confidence`（0-1）、`supportingEpisodes`、`contradictingEpisodes`
- 用户可确认、修改、删除规则

#### Scenario: 三层记忆协作——续写打斗场景

- **假设** 用户请求续写一段打斗场景
- **当** 系统组装 AI 上下文
- **则** 工作记忆提供当前章节上下文和本次会话意图
- **并且** 情景记忆通过语义检索召回过去 3 次用户在打斗场景中的交互记录
- **并且** 语义记忆注入规则「动作场景偏好短句、快节奏」
- **并且** 三层记忆经 Context Engine 整合后喂入 AI

#### Scenario: 工作记忆容量超限时的淘汰

- **假设** 工作记忆中已累积 8K tokens 的内容
- **当** 新的编辑上下文写入工作记忆
- **则** 系统按 `importance` 分数从低到高淘汰内容
- **并且** 与当前编辑焦点无关的旧会话意图优先被淘汰
- **并且** 淘汰不影响编辑器操作

#### Scenario: 会话结束时工作记忆归档

- **假设** 用户关闭应用或切换项目
- **当** 当前编辑会话结束
- **则** 工作记忆中达到阈值的临时偏好信号压缩归档为情景记忆
- **并且** 未达阈值的信号直接丢弃
- **并且** 工作记忆清空

---

### Requirement: 情景记忆记录与隐式反馈提取

系统**必须**在每次 AI 技能执行后自动记录情景记忆（Episode），捕获用户的显式和隐式反馈信号。

每个情景记忆的数据结构**必须**包含：

- **触发上下文**：`skillUsed`（使用的技能）、`inputContext`（输入上下文摘要）、`projectId`、`chapterId`、`sceneType`（场景类型：对白、动作、描写等）
- **AI 输出**：`candidates`（AI 生成的候选方案）、`selectedIndex`（用户选择的方案，-1 表示全部拒绝）、`finalText`（用户最终采用的文本）
- **用户反馈**：`explicit`（显式评价文本）、`implicit`（隐式信号）、`editDistance`（用户对 AI 输出的修改距离）
- **元数据**：`importance`、`recallCount`、`lastRecalledAt`、`compressed`

隐式反馈信号提取规则：

| 隐式信号                           | 解读          | 权重             |
| ---------------------------------- | ------------- | ---------------- |
| 用户直接接受 AI 输出，无修改       | 强正反馈      | 高               |
| 用户小幅修改（editDistance < 20%） | 弱正反馈      | 中               |
| 用户大幅改写（editDistance > 60%） | 弱负反馈      | 中               |
| 用户完全拒绝所有候选方案           | 强负反馈      | 高               |
| 用户撤销了之前接受的 AI 输出       | 延迟负反馈    | 最高             |
| 用户反复对同类场景使用同一技能     | 场景-技能偏好 | 低（累积后变高） |

情景记忆通过 IPC 通道持久化：

| IPC 通道                | 通信模式         | 方向            | 用途         |
| ----------------------- | ---------------- | --------------- | ------------ |
| `memory:episode:record` | Fire-and-Forget  | Renderer → Main | 记录情景记忆 |
| `memory:episode:query`  | Request-Response | Renderer → Main | 查询情景记忆 |

#### Scenario: AI 技能执行后自动记录情景

- **假设** 用户在第七章的打斗场景中使用了续写技能
- **当** AI 返回 3 个候选方案，用户选择方案 B 并做了小幅修改（editDistance = 15%）
- **则** 系统自动创建一条情景记忆
- **并且** 记录 `skillUsed: "continue"`、`sceneType: "action"`、`selectedIndex: 1`、`editDistance: 0.15`
- **并且** 隐式反馈标记为「弱正反馈」
- **并且** 通过 `memory:episode:record` 持久化到 SQLite

#### Scenario: 用户撤销 AI 输出——延迟负反馈

- **假设** 用户接受了 AI 的润色结果
- **当** 用户在 30 秒后执行撤销（Undo），恢复原文
- **则** 系统更新对应情景记忆的反馈为「延迟负反馈」（权重最高）
- **并且** 该信号在后续语义记忆蒸馏中被重点考虑

#### Scenario: 情景记忆召回

- **假设** 用户在第十五章触发续写，场景类型为「对白」
- **当** 系统准备 AI 上下文
- **则** 通过 `memory:episode:query` 按场景类型 + 语义相似度混合召回相关历史情景
- **并且** 返回最相关的 3-5 条情景作为参考

---

### Requirement: 语义记忆蒸馏

系统**必须**从情景记忆中自动蒸馏出抽象的偏好规则，生成语义记忆条目。

蒸馏流程：

```
情景记忆（大量具体事件）
       │
       ▼
   聚类分析（按场景类型、技能类型分组）
       │
       ▼
   模式提取（统计显著的偏好模式）
       │
       ▼
   自然语言规则生成
       │
       ▼
   语义记忆条目（可直接注入 Settings 层）
```

语义记忆条目结构**必须**包含：`id`、`rule`（自然语言描述）、`category`（`style` | `structure` | `character` | `pacing` | `vocabulary`）、`scope`（`global` | `project`）、`confidence`（0-1）、`supportingEpisodes`、`contradictingEpisodes`、`userConfirmed`、`userModified`、`version`。

蒸馏触发条件：

1. **批量触发**：累积 50 个新情景后
2. **空闲触发**：用户离开编辑器 > 5 分钟时后台执行
3. **手动触发**：用户在记忆面板中点击「更新偏好」
4. **冲突触发**：检测到新情景与现有语义记忆矛盾时

蒸馏过程**必须**调用 LLM（mock 环境下使用 mock），但**必须**在后台异步执行，不阻塞用户编辑。

语义记忆注入 Context Engine 的 Settings 层，格式示例：

```
[用户写作偏好 - 自动学习]
- 动作场景：偏好短句（平均 < 15 字），节奏紧凑（置信度: 0.87）
- 对白风格：口语化，避免书面语气（置信度: 0.92）
- 叙事视角：严格第一人称（置信度: 0.95，用户已确认）
```

语义记忆的 IPC 通道：

| IPC 通道                  | 通信模式          | 方向            | 用途             |
| ------------------------- | ----------------- | --------------- | ---------------- |
| `memory:semantic:list`    | Request-Response  | Renderer → Main | 列出语义记忆规则 |
| `memory:semantic:update`  | Request-Response  | Renderer → Main | 更新规则         |
| `memory:semantic:delete`  | Request-Response  | Renderer → Main | 删除规则         |
| `memory:semantic:add`     | Request-Response  | Renderer → Main | 手动添加规则     |
| `memory:semantic:distill` | Request-Response  | Renderer → Main | 手动触发蒸馏     |
| `memory:distill:progress` | Push Notification | Main → Renderer | 蒸馏进度通知     |

#### Scenario: 批量触发语义记忆蒸馏

- **假设** 系统已累积 50 个新情景记忆
- **当** 下一次 AI 技能执行完成
- **则** 系统在后台启动蒸馏流程
- **并且** 通过 `memory:distill:progress` 推送进度到记忆面板
- **并且** 蒸馏完成后生成或更新语义记忆规则
- **并且** 蒸馏过程不阻塞编辑器操作

#### Scenario: 蒸馏产生新规则

- **假设** 最近 50 个情景中，有 35 个动作场景的用户均选择了短句方案
- **当** 蒸馏流程分析这些情景
- **则** 生成新规则「动作场景偏好短句，平均句长 < 15 字」，置信度 0.87
- **并且** 规则标记为 `userConfirmed: false`，等待用户在记忆面板中确认

#### Scenario: 蒸馏服务不可用时的降级

- **假设** 蒸馏依赖的 LLM 调用失败
- **当** 蒸馏流程执行
- **则** 蒸馏失败静默记录到日志，不弹 Toast
- **并且** 已有的语义记忆规则保持不变
- **并且** 下次触发条件满足时重试

---

### Requirement: 记忆衰减与生命周期管理

系统**必须**实现基于遗忘曲线的时间衰减模型，管理记忆的生命周期。

衰减公式：

```
decay = min(1.0, baseDecay × recallBoost × importanceBoost)
baseDecay = exp(-0.1 × ageInDays)
recallBoost = 1 + 0.2 × recallCount
importanceBoost = 1 + 0.3 × importance
```

衰减分级：

| 等级   | 分数范围  | 状态           | 处理方式         |
| ------ | --------- | -------------- | ---------------- |
| 活跃   | 0.7 - 1.0 | 正常参与召回   | 无需处理         |
| 衰减中 | 0.3 - 0.7 | 降低召回优先级 | 被召回则重新激活 |
| 待压缩 | 0.1 - 0.3 | 不再参与召回   | 等待批量压缩     |
| 待淘汰 | < 0.1     | 候选删除       | 下次清理时删除   |

**压缩策略**：

- 待压缩的情景记忆不直接删除，而是压缩为摘要（~200 tokens）
- 压缩保留：场景类型 + 技能 + 反馈 + 关键偏好信号 + 风格特征
- 压缩丢弃：完整 AI 候选方案 + 完整输入上下文 + 逐字编辑历史
- 压缩后标记 `compressed: true`，释放原始数据

**免衰减规则**：

- 标记为「核心设定」的记忆**不受衰减影响**
- 用户在记忆面板中已确认（`userConfirmed: true`）的语义记忆**不受衰减影响**

**存储预算**：

| 记忆类型         | 预算              | 超出处理         |
| ---------------- | ----------------- | ---------------- |
| 工作记忆         | 8K tokens（内存） | 按重要性淘汰     |
| 情景记忆（活跃） | 最近 1000 条      | 衰减 → 压缩      |
| 情景记忆（压缩） | 最近 5000 条      | 衰减 → 淘汰      |
| 语义记忆         | 最多 200 条规则   | 按置信度淘汰低分 |

**清理调度**：

- 实时：工作记忆淘汰（每次写入时检查）
- 每日：情景记忆衰减分数重算（应用启动时）
- 每周：批量压缩 + 语义记忆蒸馏
- 每月：淘汰已压缩的过期情景记忆

#### Scenario: 情景记忆衰减到待压缩状态

- **假设** 一条 60 天前的情景记忆，从未被召回（recallCount = 0）
- **当** 每日衰减分数重算执行
- **则** 该记忆的衰减分数降至 0.25（待压缩区间）
- **并且** 在下次批量压缩时被压缩为摘要

#### Scenario: 被召回的记忆重新激活

- **假设** 一条衰减中（分数 0.5）的情景记忆
- **当** 该记忆被 AI 续写的上下文召回引用
- **则** `recallCount` 加 1，`lastRecalledAt` 更新为当前时间
- **并且** 衰减分数重算后回升至活跃区间

#### Scenario: 用户确认的记忆免于衰减

- **假设** 语义记忆规则「严格第一人称叙述」已被用户确认
- **当** 衰减分数重算执行
- **则** 该规则跳过衰减计算，始终保持 confidence 不变

---

### Requirement: 记忆冲突检测与解决

系统**必须**检测语义记忆规则之间的冲突，并按策略自动或提示用户解决。

冲突类型：

| 冲突类型                       | 自动解决策略                     | 需要用户确认             |
| ------------------------------ | -------------------------------- | ------------------------ |
| 时间迁移（新旧偏好不同）       | 以近 30 天情景为准，自动更新规则 | 否（标注「最近更新」）   |
| 作用域重叠（全局 vs 项目）     | 项目级规则优先，全局规则降权     | 否                       |
| 直接矛盾（同时期两条互斥规则） | 降低两条规则的置信度             | 是（弹出提示让用户选择） |

冲突检测在每次蒸馏完成后自动执行。

#### Scenario: 时间迁移——用户风格变化

- **假设** 旧规则「偏好华丽辞藻」（60 天前，置信度 0.75），近 30 天情景显示用户转向简洁风格
- **当** 蒸馏完成并检测到冲突
- **则** 系统自动更新规则为「偏好简洁风格」
- **并且** 记忆面板中该规则标注「最近更新」

#### Scenario: 直接矛盾——用户选择解决

- **假设** 蒸馏产生两条互斥规则：「偏好长句」和「偏好短句」
- **当** 冲突检测触发
- **则** 两条规则置信度降低
- **并且** 记忆面板弹出通知「检测到偏好冲突，请选择你更倾向的风格」
- **当** 用户选择「偏好短句」
- **则** 「偏好短句」标记为 `userConfirmed`，「偏好长句」被删除

---

### Requirement: 记忆面板（Memory Panel）——用户可见性与控制

系统**必须**提供记忆面板作为用户查看和管理 AI 记忆的统一界面，位于左侧栏（可通过 Icon Bar 扩展入口访问或在设置中打开）。

记忆面板结构：

- **作用域切换**：顶部标签切换「全局」/「本项目」
- **规则列表**：按分类（写作风格、叙事偏好、角色偏好、节奏、词汇）分组展示语义记忆规则
- **每条规则展示**：规则文本、置信度百分比、确认状态
- **操作按钮**：确认、修改、删除
- **底部信息区**：已积累的交互记录数、最近更新时间
- **功能按钮**：「查看学习历史」「手动添加规则」「更新偏好」（手动触发蒸馏）「暂停学习」

用户可执行的操作：

| 操作     | 效果                                               | 适用场景               |
| -------- | -------------------------------------------------- | ---------------------- |
| 确认     | 标记 `userConfirmed`，提升权重，不再被自动更新覆盖 | AI 学到了正确的偏好    |
| 修改     | 用户编辑规则文本，标记 `userModified`              | AI 方向对但表述不准确  |
| 删除     | 永久移除规则，支撑情景标记为负向避免重新蒸馏       | AI 学到了错误的偏好    |
| 手动添加 | 直接写入规则，置信度 1.0，`userConfirmed: true`    | 用户直接告诉 AI 偏好   |
| 暂停学习 | 冻结语义记忆蒸馏，停止从新情景更新规则             | 实验性写作，防污染偏好 |

记忆面板使用 `--color-bg-surface` 背景。规则卡片使用 `--color-bg-raised` 背景，`--radius-sm` 圆角。

记忆面板组件**必须**有 Storybook Story，覆盖：有多条规则的默认态、空态（新用户）、暂停学习态、冲突通知态。

#### Scenario: 用户确认 AI 学到的偏好

- **假设** 记忆面板显示规则「动作场景偏好短句」（置信度 87%，未确认）
- **当** 用户点击「确认」按钮
- **则** 规则标记为 `userConfirmed: true`
- **并且** 规则不再受自动蒸馏覆盖
- **并且** 规则不受时间衰减影响

#### Scenario: 用户手动添加偏好规则

- **假设** 用户打开记忆面板
- **当** 用户点击「手动添加规则」，输入「所有角色对白不使用感叹号」
- **则** 系统通过 `memory:semantic:add` 创建规则
- **并且** 规则置信度为 1.0，`userConfirmed: true`
- **并且** 立即生效，注入后续 AI 推理的 Settings 层

#### Scenario: 用户删除错误偏好

- **假设** AI 错误学到规则「偏好使用文言文句式」
- **当** 用户在记忆面板中点击该规则的「删除」按钮
- **则** 系统通过 `memory:semantic:delete` 删除规则
- **并且** 支撑该规则的情景记忆标记为负向信号
- **并且** 后续蒸馏不会重新生成该规则

#### Scenario: 用户暂停学习

- **假设** 用户正在进行实验性写作（尝试新风格）
- **当** 用户在记忆面板中点击「暂停学习」
- **则** 语义记忆蒸馏暂停，新情景仍被记录但不触发蒸馏
- **并且** 面板顶部显示「学习已暂停」状态标签（`--color-warning` 背景）
- **当** 用户点击「恢复学习」
- **则** 蒸馏恢复正常

#### Scenario: 记忆面板空状态

- **假设** 新用户或新项目，没有任何语义记忆
- **当** 用户打开记忆面板
- **则** 显示空状态：图标 + 文案「AI 正在学习你的写作偏好，使用越多越精准」
- **并且** 提供「手动添加规则」按钮

---

### Requirement: 记忆溯源（Memory Provenance）

系统**必须**支持记忆溯源——用户可查看 AI 输出是基于哪些记忆做出的决策。

每次 AI 生成内容时，系统**必须**记录记忆引用链（`GenerationTrace`），包含：

- `generationId`：生成 ID
- `memoryReferences`：引用的工作记忆项 ID、情景记忆 ID、语义记忆规则 ID
- `influenceWeights`：每条记忆对最终输出的影响权重

用户可在 AI 面板中对 AI 输出点击「为什么这样写？」查看溯源信息。

溯源 UI 展示：按记忆类型分组列出引用的记忆条目及影响权重，用户可对溯源结果反馈「判断正确」或「判断有误」。

溯源的 IPC 通道：

| IPC 通道                | 通信模式         | 方向            | 用途             |
| ----------------------- | ---------------- | --------------- | ---------------- |
| `memory:trace:get`      | Request-Response | Renderer → Main | 获取生成溯源信息 |
| `memory:trace:feedback` | Fire-and-Forget  | Renderer → Main | 用户对溯源的反馈 |

#### Scenario: 用户查看 AI 输出的记忆溯源

- **假设** AI 续写了一段短句风格的打斗场景
- **当** 用户点击 AI 输出旁的「为什么这样写？」
- **则** 系统通过 `memory:trace:get` 获取溯源信息
- **并且** 展示溯源面板：语义记忆「动作场景偏好短句」（影响 35%）、情景记忆「3月15日打斗场景」（影响 25%）、工作记忆「当前章节上下文」（影响 20%）

#### Scenario: 用户反馈溯源判断有误

- **假设** 溯源显示 AI 参考了「偏好华丽辞藻」规则
- **当** 用户点击「判断有误」
- **则** 系统通过 `memory:trace:feedback` 记录负反馈
- **并且** 该规则的置信度降低
- **并且** 负反馈作为新情景记忆参与后续蒸馏

---

### Requirement: 记忆隔离与作用域

记忆**必须**分为**全局级**和**项目级**两个作用域。

作用域优先级：

1. **项目级语义记忆** > **全局级语义记忆**
2. 无项目级匹配时回退到全局级
3. 两者冲突时项目级覆盖全局级
4. 用户可手动将项目级规则「提升」为全局级

记忆清除支持两种粒度：

- **项目级清除**：仅清除某个项目的记忆（情景 + 语义），不影响其他项目和全局记忆
- **全量清除**：清除所有记忆，恢复到全新用户状态

清除操作**必须**有确认流程。

清除的 IPC 通道：

| IPC 通道               | 通信模式         | 方向            | 用途           |
| ---------------------- | ---------------- | --------------- | -------------- |
| `memory:clear:project` | Request-Response | Renderer → Main | 项目级清除     |
| `memory:clear:all`     | Request-Response | Renderer → Main | 全量清除       |
| `memory:promote`       | Request-Response | Renderer → Main | 提升规则作用域 |

#### Scenario: 项目级记忆覆盖全局记忆

- **假设** 全局规则「偏好第一人称」，项目「科幻短篇」有项目级规则「使用第三人称全知」
- **当** 用户在「科幻短篇」项目中触发续写
- **则** Context Engine 注入项目级规则「使用第三人称全知」
- **并且** 全局规则「偏好第一人称」在此项目中被忽略

#### Scenario: 用户将项目级规则提升为全局

- **假设** 项目级规则「对白避免感叹号」在多个项目中都适用
- **当** 用户在记忆面板中点击「提升为全局」
- **则** 系统通过 `memory:promote` 将规则 scope 从 `project` 改为 `global`
- **并且** 该规则在所有项目中生效

#### Scenario: 用户执行项目级清除

- **假设** 用户想清除项目「实验小说」的所有记忆
- **当** 用户在记忆面板中点击「清除本项目记忆」并确认
- **则** 系统通过 `memory:clear:project` 删除该项目的所有情景记忆和项目级语义记忆
- **并且** 全局记忆不受影响
- **并且** Toast 通知「已清除项目"实验小说"的记忆」

---

### Requirement: 记忆系统降级策略

记忆系统的任何子模块故障都**不应**阻断核心写作功能。系统**必须**实现完整的降级策略。

| 故障场景                       | 降级策略                                       | 用户感知                     |
| ------------------------------ | ---------------------------------------------- | ---------------------------- |
| 向量索引不可用（无法语义召回） | 回退到时间 + 场景类型精确匹配                  | 召回精度下降，不中断         |
| 语义记忆为空（新用户/新项目）  | 使用内置默认规则 + Settings 层的显式设定       | AI 输出偏通用，逐渐个性化    |
| 情景记忆数据库损坏             | 语义记忆仍可用（已蒸馏的规则独立于原始数据）   | 失去案例参考，偏好规则仍在   |
| 全部记忆不可用                 | 仅依赖 Context Engine 的 Rules 和 Immediate 层 | 等同无记忆模式，基础功能完整 |

#### Scenario: 向量索引故障时的语义召回降级

- **假设** 向量索引服务不可用
- **当** 系统尝试通过语义相似度召回情景记忆
- **则** 系统自动回退到基于时间和场景类型的精确匹配
- **并且** 在应用日志中记录降级事件
- **并且** 编辑器和 AI 功能正常运行

#### Scenario: 全部记忆不可用时的兜底

- **假设** 记忆系统的 SQLite 数据库不可读
- **当** 用户触发 AI 续写
- **则** Context Engine 跳过记忆层注入
- **并且** AI 仅依赖 Immediate 层和 Rules 层进行续写
- **并且** 状态栏或 AI 面板显示降级提示「记忆系统暂时不可用，AI 将以通用模式工作」

---

### Requirement: 存储策略与淘汰机制执行细则（LRU + TTL）

记忆存储必须采用可验证的分层淘汰策略，避免无限增长。

执行规则：

- 工作记忆：基于 `importance` 的 LRU 淘汰
- 情景记忆：`TTL=180 天`，到期进入压缩队列
- 压缩记忆：`TTL=365 天`，到期物理删除
- 语义记忆：按 `confidence` 升序淘汰，保留用户确认规则

淘汰触发时机：

- 写入前容量检查（同步）
- 每日 02:00 增量清理（后台任务）
- 手动「立即清理」触发（运维入口）

#### Scenario: 情景记忆超过上限触发 LRU+TTL 淘汰

- **假设** 某项目情景记忆达到 10,000 条上限
- **当** 新情景写入
- **则** 系统先删除过期（>180 天）未确认记忆
- **并且** 若仍超限，按 LRU 从低热度到高热度淘汰
- **并且** 用户确认记忆不被淘汰

#### Scenario: 记忆检索失败时降级到默认规则

- **假设** 情景库与语义库均不可读
- **当** Context Engine 请求记忆注入
- **则** 返回内置默认风格规则集并标记 `memoryDegraded=true`
- **并且** AI 续写继续可用

---

### Requirement: 模块级可验收标准（适用于本模块全部 Requirement）

- 量化阈值：
  - `memory:episode:record` p95 < 150ms
  - `memory:episode:query` p95 < 220ms
  - `memory:semantic:list` p95 < 180ms
- 边界与类型安全：
  - `TypeScript strict` + zod
  - 记忆对象必须带 `projectId/scope/version`
- 失败处理策略：
  - 写失败返回硬错误并重试最多 3 次
  - 读失败可降级但必须可见（状态栏或 AI 面板）
  - 清理任务失败必须告警，不可静默
- Owner 决策边界：
  - 记忆层级定义、TTL、作用域优先级由 Owner 固定
  - Agent 不得私改衰减核心公式

#### Scenario: 记忆读写指标达标

- **假设** 连续执行 10,000 次写入和 5,000 次检索
- **当** 统计耗时
- **则** 写入 p95 < 150ms、检索 p95 < 220ms
- **并且** 错误率 < 1%

#### Scenario: 清理任务失败触发告警

- **假设** 每日清理任务执行时数据库锁死
- **当** 清理失败
- **则** 记录 `MEMORY_CLEANUP_FAILED` 并上报告警
- **并且** 下一调度窗口自动重试

---

### Requirement: 异常与边界覆盖矩阵

| 类别         | 最低覆盖要求                             |
| ------------ | ---------------------------------------- |
| 网络/IO 失败 | 记忆库读写失败、蒸馏调用失败             |
| 数据异常     | 置信度越界、episode 字段缺失、trace 失配 |
| 并发冲突     | 并发蒸馏与写入冲突、并发清理冲突         |
| 容量溢出     | 记忆条目超上限、压缩队列堆积             |
| 权限/安全    | 跨项目读取、全量清除未确认               |

#### Scenario: 并发蒸馏与写入冲突隔离

- **假设** 蒸馏任务正在批量读取 episodes
- **当** 同时有新 episode 写入
- **则** 写入先入 WAL 队列，不阻塞在线请求
- **并且** 蒸馏使用一致性快照读取

#### Scenario: 全量清除必须二次确认

- **假设** 用户触发 `memory:clear:all`
- **当** 未通过二次确认
- **则** 返回 `MEMORY_CLEAR_CONFIRM_REQUIRED`
- **并且** 不执行任何删除

---

### Non-Functional Requirements

**Performance**

- 记录情景：p50 < 60ms，p95 < 150ms，p99 < 300ms
- 语义检索：p50 < 90ms，p95 < 220ms，p99 < 450ms
- 溯源查询：p95 < 250ms

**Capacity**

- 单项目情景记忆上限：10,000
- 单项目语义规则上限：500
- 压缩记忆上限：50,000

**Security & Privacy**

- 记忆数据按项目隔离，敏感字段（人名映射）可配置脱敏
- 日志中禁止输出完整 episode 文本
- 全量清除需记录操作人和时间戳

**Concurrency**

- 写入与查询可并发，清理任务独占低优先锁
- 蒸馏任务最多并行 1 个
- 并发查询最大 32

#### Scenario: 记忆上限自动回收

- **假设** 项目记忆达到上限
- **当** 新写入到达
- **则** 自动触发回收并保持写入成功率
- **并且** 不影响在线查询

#### Scenario: 并发查询背压

- **假设** 同时发起 80 个记忆查询
- **当** 超出并发上限 32
- **则** 超限请求返回 `MEMORY_BACKPRESSURE`
- **并且** 已执行查询不超时
